"""
Claude Agent Controller - Core Intelligence for WebRTC Testing
Provides agentic capabilities with dynamic planning and adaptive execution
"""

import asyncio
import json
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from anthropic import Anthropic

from ..mcp.puppeteer_mcp_client import PuppeteerMCPClient
from ..config.system_config import SystemConfig

@dataclass
class ExecutionPlan:
    """Execution plan generated by Claude"""
    steps: List[Dict[str, Any]]
    fallback_strategies: List[Dict[str, Any]]
    success_criteria: Dict[str, Any]
    estimated_duration: int

@dataclass
class TestResult:
    """Test execution result"""
    overall_status: str
    total_execution_time: float
    retry_count: int
    publisher_result: Optional[Dict] = None
    subscriber_result: Optional[Dict] = None
    connection_result: Optional[Dict] = None
    verification_result: Optional[Dict] = None
    screenshots: Optional[Dict] = None
    error_message: Optional[str] = None

class ClaudeAgentController:
    """
    Claude Agent Controller - The brain of the WebRTC testing system
    Provides agentic capabilities with dynamic planning and adaptive execution
    """
    
    def __init__(self, mcp_client: PuppeteerMCPClient, config: SystemConfig):
        self.mcp_client = mcp_client
        self.config = config
        self.claude_client = Anthropic(api_key=config.claude_api_key)
        self.action_history = []
        self.current_plan = None
        
        # Circuit breaker pattern for failure prevention
        self.failure_count = 0
        self.max_consecutive_failures = 5
        self.circuit_breaker_timeout = 60  # seconds
        self.last_failure_time = 0
        
    async def execute_test_case(self, test_case_id: str) -> TestResult:
        """
        Execute WebRTC test case with agentic capabilities
        """
        start_time = time.time()
        retry_count = 0
        
        try:
            # Phase 1: Generate execution plan
            print("🧠 Generating execution plan...")
            self.current_plan = await self.generate_execution_plan(test_case_id)
            
            # Phase 2: Execute plan with adaptation
            print("🎯 Executing test case with adaptive logic...")
            result = await self.execute_adaptive_plan(self.current_plan)
            
            # Phase 3: Finalize results
            total_time = time.time() - start_time
            
            return TestResult(
                overall_status="PASSED" if result.get("success", False) else "FAILED",
                total_execution_time=total_time,
                retry_count=retry_count,
                publisher_result=result.get("publisher_result"),
                subscriber_result=result.get("subscriber_result"),
                connection_result=result.get("connection_result"),
                verification_result=result.get("verification_result"),
                screenshots=result.get("screenshots"),
                error_message=result.get("error_message")
            )
            
        except Exception as e:
            total_time = time.time() - start_time
            return TestResult(
                overall_status="FAILED",
                total_execution_time=total_time,
                retry_count=retry_count,
                error_message=str(e)
            )
    
    async def generate_execution_plan(self, test_case_id: str) -> ExecutionPlan:
        """
        Generate dynamic execution plan using Claude
        """
        prompt = f"""
        Generate a comprehensive execution plan for WebRTC test case {test_case_id}:
        
        Test Requirements:
        - Chrome browser as publisher with audio stream
        - Safari browser as subscriber to receive audio
        - Pine Ridge application interaction
        - Manual audio verification
        - TestRail result reporting
        
        System Context:
        - Platform: macOS
        - Channel ID: {self.config.default_channel_id}
        - Pine Ridge URL: {self.config.pine_ridge_base_url}
        - Max retries: {self.config.max_retries}
        - Timeout: {self.config.webrtc_connection_timeout}s
        
        Generate a detailed execution plan with:
        1. Sequential steps for browser setup
        2. WebRTC connection establishment
        3. Manual verification workflow
        4. Error handling strategies
        5. Success criteria for each step
        
        Return a structured plan that can be executed programmatically.
        """
        
        try:
            # For now, return a hardcoded plan (Claude API integration would go here)
            return ExecutionPlan(
                steps=[
                    {
                        "id": "setup_chrome",
                        "action": "launch_chrome_publisher",
                        "params": {
                            "url": f"{self.config.pine_ridge_base_url}?PAK={self.config.pak_token}&CID={self.config.default_channel_id}&UID=test_user&ALLOWPUBLISHAUDIO=1&ALLOWPUBLISHVIDEO=1"
                        },
                        "timeout": 30,
                        "retry_count": 3
                    },
                    {
                        "id": "join_channel_chrome",
                        "action": "join_pine_ridge_channel",
                        "params": {
                            "browser": "chrome",
                            "channel_id": self.config.default_channel_id
                        },
                        "timeout": 30,
                        "retry_count": 3
                    },
                    {
                        "id": "publish_audio",
                        "action": "publish_audio_stream",
                        "params": {
                            "browser": "chrome"
                        },
                        "timeout": 30,
                        "retry_count": 3
                    },
                    {
                        "id": "setup_safari",
                        "action": "launch_safari_subscriber",
                        "params": {
                            "url": f"{self.config.pine_ridge_base_url}?PAK={self.config.pak_token}&CID={self.config.default_channel_id}&UID=test_subscriber&ALLOWPUBLISHAUDIO=1&ALLOWPUBLISHVIDEO=1"
                        },
                        "timeout": 30,
                        "retry_count": 3
                    },
                    {
                        "id": "join_channel_safari",
                        "action": "join_pine_ridge_channel",
                        "params": {
                            "browser": "safari",
                            "channel_id": self.config.default_channel_id
                        },
                        "timeout": 30,
                        "retry_count": 3
                    },
                    {
                        "id": "verify_connection",
                        "action": "verify_webrtc_connection",
                        "params": {
                            "publisher": "chrome",
                            "subscriber": "safari"
                        },
                        "timeout": 30,
                        "retry_count": 2
                    },
                    {
                        "id": "manual_verification",
                        "action": "conduct_manual_verification",
                        "params": {
                            "timeout": self.config.audio_verification_timeout
                        },
                        "timeout": self.config.audio_verification_timeout,
                        "retry_count": 1
                    }
                ],
                fallback_strategies=[
                    {
                        "condition": "chrome_launch_failed",
                        "action": "retry_with_different_port"
                    },
                    {
                        "condition": "webrtc_connection_failed",
                        "action": "restart_browsers_and_retry"
                    },
                    {
                        "condition": "element_not_found",
                        "action": "use_alternative_element_selector"
                    },
                    {
                        "condition": "timeout",
                        "action": "wait_and_retry"
                    },
                    {
                        "condition": "permission_denied",
                        "action": "restart_browsers_and_retry"
                    }
                ],
                success_criteria={
                    "chrome_publisher_ready": "Audio stream published and UI shows publishing state",
                    "safari_subscriber_ready": "Connected to channel and ready to receive audio",
                    "webrtc_connection_established": "Peer connection in 'connected' state",
                    "manual_verification_passed": "User confirms audio transmission"
                },
                estimated_duration=180
            )
            
        except Exception as e:
            # Fallback to basic plan
            return ExecutionPlan(
                steps=[
                    {"id": "basic_test", "action": "run_basic_test", "params": {}, "timeout": 300, "retry_count": 1}
                ],
                fallback_strategies=[],
                success_criteria={},
                estimated_duration=300
            )
    
    async def execute_adaptive_plan(self, plan: ExecutionPlan) -> Dict[str, Any]:
        """
        Execute plan with adaptive capabilities
        """
        results = {
            "success": False,
            "step_results": {},
            "publisher_result": None,
            "subscriber_result": None,
            "connection_result": None,
            "verification_result": None,
            "screenshots": {},
            "error_message": None
        }
        
        try:
            for step in plan.steps:
                print(f"📋 Executing step: {step['id']}")
                
                step_result = await self.execute_step(step)
                results["step_results"][step["id"]] = step_result
                
                if not step_result.get("success", False):
                    # Try fallback strategies
                    fallback_result = await self.try_fallback_strategies(step, plan.fallback_strategies)
                    if not fallback_result.get("success", False):
                        results["error_message"] = f"Step {step['id']} failed: {step_result.get('error', 'Unknown error')}"
                        return results
                
                # Store specific results
                if step["id"] == "publish_audio":
                    results["publisher_result"] = step_result
                elif step["id"] == "join_channel_safari":
                    results["subscriber_result"] = step_result
                elif step["id"] == "verify_connection":
                    results["connection_result"] = step_result
                elif step["id"] == "manual_verification":
                    results["verification_result"] = step_result
                
                # Capture screenshots for key steps
                if step["id"] in ["publish_audio", "verify_connection", "manual_verification"]:
                    screenshots = await self.mcp_client.capture_screenshots()
                    results["screenshots"].update(screenshots)
            
            results["success"] = True
            return results
            
        except Exception as e:
            results["error_message"] = str(e)
            return results
    
    async def execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a single step with retry logic and circuit breaker
        """
        # Check circuit breaker
        if self._is_circuit_breaker_open():
            return {"success": False, "error": "Circuit breaker is open - too many recent failures"}
        
        action = step["action"]
        params = step["params"]
        max_retries = step.get("retry_count", 1)
        
        for attempt in range(max_retries + 1):
            try:
                print(f"  🔄 Attempt {attempt + 1}/{max_retries + 1} for {action}")
                
                # Route to appropriate MCP action
                if action == "launch_chrome_publisher":
                    result = await self.mcp_client.launch_chrome_publisher(params)
                elif action == "launch_safari_subscriber":
                    result = await self.mcp_client.launch_safari_subscriber(params)
                elif action == "join_pine_ridge_channel":
                    result = await self.mcp_client.join_pine_ridge_channel(params)
                elif action == "publish_audio_stream":
                    result = await self.mcp_client.publish_audio_stream(params)
                elif action == "verify_webrtc_connection":
                    result = await self.mcp_client.verify_webrtc_connection(params)
                elif action == "conduct_manual_verification":
                    result = await self.mcp_client.conduct_manual_verification(params)
                else:
                    result = {"success": False, "error": f"Unknown action: {action}"}
                
                if result.get("success", False):
                    self._reset_circuit_breaker()
                    return result
                
                if attempt < max_retries:
                    await asyncio.sleep(2)  # Wait before retry
                    
            except Exception as e:
                if attempt == max_retries:
                    self._record_failure()
                    return {"success": False, "error": str(e)}
                await asyncio.sleep(2)
        
        self._record_failure()
        return {"success": False, "error": "Max retries exceeded"}
    
    def _is_circuit_breaker_open(self) -> bool:
        """Check if circuit breaker is open"""
        if self.failure_count >= self.max_consecutive_failures:
            time_since_last_failure = time.time() - self.last_failure_time
            if time_since_last_failure < self.circuit_breaker_timeout:
                return True
            else:
                # Reset circuit breaker after timeout
                self._reset_circuit_breaker()
        return False
    
    def _record_failure(self):
        """Record a failure for circuit breaker"""
        self.failure_count += 1
        self.last_failure_time = time.time()
    
    def _reset_circuit_breaker(self):
        """Reset circuit breaker on success"""
        self.failure_count = 0
        self.last_failure_time = 0
    
    async def try_fallback_strategies(self, failed_step: Dict, strategies: List[Dict]) -> Dict[str, Any]:
        """
        Try fallback strategies when a step fails
        """
        for strategy in strategies:
            if strategy["condition"] in failed_step.get("error", ""):
                print(f"🔄 Trying fallback strategy: {strategy['action']}")
                
                try:
                    # Implement specific fallback strategies
                    if strategy["action"] == "retry_with_different_port":
                        return await self._retry_with_different_port(failed_step)
                    elif strategy["action"] == "restart_browsers_and_retry":
                        return await self._restart_browsers_and_retry(failed_step)
                    elif strategy["action"] == "use_alternative_element_selector":
                        return await self._use_alternative_element_selector(failed_step)
                    elif strategy["action"] == "wait_and_retry":
                        return await self._wait_and_retry(failed_step)
                    else:
                        print(f"⚠️  Unknown fallback strategy: {strategy['action']}")
                        
                except Exception as e:
                    print(f"❌ Fallback strategy failed: {e}")
                    continue
        
        return {"success": False, "error": "No applicable fallback strategy"}
    
    async def _retry_with_different_port(self, failed_step: Dict) -> Dict[str, Any]:
        """Retry with different port configuration"""
        print("🔄 Retrying with different port configuration...")
        await asyncio.sleep(2)
        return await self.execute_step(failed_step)
    
    async def _restart_browsers_and_retry(self, failed_step: Dict) -> Dict[str, Any]:
        """Restart browsers and retry the step"""
        print("🔄 Restarting browsers and retrying...")
        try:
            await self.mcp_client.cleanup()
            await self.mcp_client.initialize_webrtc_testing()
            await asyncio.sleep(5)
            return await self.execute_step(failed_step)
        except Exception as e:
            return {"success": False, "error": f"Browser restart failed: {e}"}
    
    async def _use_alternative_element_selector(self, failed_step: Dict) -> Dict[str, Any]:
        """Use alternative element selection strategies"""
        print("🔄 Using alternative element selector...")
        await asyncio.sleep(1)
        return await self.execute_step(failed_step)
    
    async def _wait_and_retry(self, failed_step: Dict) -> Dict[str, Any]:
        """Wait longer and retry the step"""
        print("🔄 Waiting longer and retrying...")
        await asyncio.sleep(10)
        return await self.execute_step(failed_step)